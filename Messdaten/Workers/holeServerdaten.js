//13.01.2013 PV//konfiguriert über WebServices Bootstrap als shared Worker, der ab Server Start einmal ausgeführt wird//oder über HTTP-Get aufgerufen wird//ds.Messdaten.query oder find funktionieren hier nichtfunction holeServerDaten() {    var einstellung = ds.Einstellungen.all();	var antwort = '';	    if (einstellung == null) {        antwort = "Fehler: keine Einstellungen gefunden";    }    else {        antwort = 'ich bin Server';        if (einstellung.slave[0] == true) {            var datenWerdenGelesen = Mutex('datenWerdenGelesen');            if (datenWerdenGelesen.tryToLock() == false) {                antwort = "Semaphor blockiert Lesen der Serverdaten";            }            else {                var ip = einstellung.server_ip[0];                var port = einstellung.server_port[0];                var recordsTotal = 0;                var httpFehler = "";                antwort = 'keine Verbindung zu ' + ip + ':' + port;                //hole fehlende Daten von Server pro Sensor                //vergebe dabei unsere eigene ID                var alleSensoren = ds.Sensoren.all();                alleSensoren.forEach(function(sensorEintrag) {                    //bilde Array der fehlenden Zeiträume ab letztem Server import                    var ende = new Date(sensorEintrag.servImpLastTime);                    var fehlZeitenArr = ds.Messdaten.fehlendeZeiten(sensorEintrag.Sensor_ID, sensorEintrag.Ort, ende);                    //Array enthält jeweils Zeit, ab der Einträge fehlen, gefolgt von der Zeit des nächsten vorhandenen Messeintrags                    //versuchen die Fehlbereiche vom Server zu holen                    while (fehlZeitenArr.length > 0) {                        var beginn = fehlZeitenArr.shift();                        var ende = fehlZeitenArr.shift();                        var empfangen = 0;                        var countChunk = 0;                        if (ende.getTime() > beginn.getTime()) {                            do {                                var urlServer = 'http://' + einstellung.server_ip + ':' + einstellung.server_port + '/rest/Messdaten/?$filter="Sensor_ID=' + sensorEintrag.Sensor_ID + '&Ort=' + sensorEintrag.Ort + '&Datum_Uhrzeit>=' + beginn.toISOString() + '&Datum_Uhrzeit<' + ende.toISOString() + '"' + '&$skip=' + empfangen.toString() + '&$top=100';                                var rq = new XMLHttpRequest();                                rq.open('GET', urlServer, false); //synchron, asynchron wird noch nicht unterstüzt                                rq.send();                                if (rq.readyState === 4) {                                    if (rq.status === 200) {                                        var daten = JSON.parse(rq.responseText);                                        for (var i = 0; i < daten.__SENT; i++) {                                            var neueDaten = ds.Messdaten.createEntity();                                            neueDaten.Datum_Uhrzeit = daten.__ENTITIES[i].Datum_Uhrzeit;                                            neueDaten.Intervall = daten.__ENTITIES[i].Intervall;                                            neueDaten.Messwert = daten.__ENTITIES[i].Messwert;                                            neueDaten.Einheit = daten.__ENTITIES[i].Einheit;                                            neueDaten.Sensor_ID = daten.__ENTITIES[i].Sensor_ID;                                            neueDaten.Ort = daten.__ENTITIES[i].Ort;                                            neueDaten.save();                                        }                                        empfangen += daten.__SENT;                                        countChunk = daten.__COUNT;                                    }                                    else {                                        httpFehler += rq.status + " : Sensor_ID=" + sensorEintrag.Sensor_ID + " AND Ort=" + sensorEintrag.Ort + ' AND Datum_Uhrzeit>=' + beginn.toISOString() + " AND Datum_Uhrzeit<" + ende.toISOString() + "\n";                                    }                                }                                recordsTotal += empfangen;                            } while (countChunk > empfangen) //alle Chunks abgeholt                        }                        if (empfangen > 0) {                            var logZeit = new Date();                            console.log(logZeit.toString() + ' SensorID:' + sensorEintrag.Sensor_ID + ' ' + sensorEintrag.Ort + ' ' + empfangen.toString() + ' Bytes importiert bis ' + ende.toString()); //06.01.2014                            sensorEintrag.servImpLastTime = ende;                            sensorEintrag.save();                        }                    }                });                antwort = recordsTotal.toString() + ' Datensätze von Server abgeholt';                var jetzt = new Date();                var logEintrag = ds.Protokoll.createEntity();                logEintrag.erstellt = jetzt;                logEintrag.beschreibung = httpFehler + antwort;                logEintrag.save();                console.log(antwort);				datenWerdenGelesen.unlock();            }  		}    }        return antwort;}console.log('holeServerDaten SharedWorker gestartet');//holeServerDaten();